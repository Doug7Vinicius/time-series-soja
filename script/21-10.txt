install.packages("forecast") #para a função ndiffs
require(forecast)
install.packages("timeSeries")
require(timeSeries) 
install.packages("randtests") #para o teste de Cox Stuart
require(radtests)
install.packages("urca")
require(urca)
require(randtests)
require(tseries)
require(stats)

data(AirPassengers)
AP <- AirPassengers

AP <- ts(AP, start = c(1949,1), frequency = 12) #

class(AP)
as.ts(AP)

summary(AP) # lembrar de sempre fazer estatatisticas descritivas

# Como ajustar modelos? (Metodologia Box e Jenkins)

# Como uma série temporal tem os dados coletados sequencialmente ao longo 
# do tempo, espera-se que ela apresente correlação seriada no tempo.
# Autocorrelação é a correlação entre os valores da série em um determinado 
# período de tempo e os valores da mesma série em um outro momento. 
# Os modelos de Box e Jenkins são modelos que visam 
# captar o comportamento da correlação entre os valores da série temporal,
# e com base nesse comportamento realizar previsões futuras.

########################################
### Identificação do modelo
########################################

x11()
plot(AP, ylab = 'Passengers')
plot(decompose(AP))

acf(AP, main="Função de Autocorrelação")

ndiffs(AP) #quant de diferenciações necessárias para a série ser estacionária
nsdiffs(AP) #quant de diferenciaçõess necessárias na parte sazonal da série

x11()
APdif<- diff(AP)
plot(APdif, ylab = 'Passengers')

x11()
APlog <- log(AP)
plot(APlog)

par(mfrow=c(1,1))

x11()
APlog.dif <- diff(APlog)
plot(APlog.dif, ylab = "Passengers")

APlog.dif2 <- diff(APlog.dif, lag=12)
plot(APlog.dif2,ylab='Passengers')

## Também podem ser utilizado os seguintes comandos:

# A série precisa de 1 diferença simples e 1 sazonal (após sua transformação)

z = diff(diff(APlog),lag=12)
plot(z, ylab='Passengers')

# Teste para verificar estacionariedade

adf.test(APlog.dif2)
# H0: A série não é estacionária
# H1: A série é estacionária
# Se p-valor < menor que alfa, rejeita-se H0. Caso contrário, não rejeita-se H0.
# A série é estacionária, pois p-valor é Menor que alfa.

#teste de Philippe Perron 
pp.test(APlog.dif2)

# Teste Kwiatkowski, Philips, Schimidt e Shin
kpss.test(APlog.dif2, null="Level")
# H0: A série é estacionaria
# H1: A série não é estacionária
# Se p-valor é menor que alfa, rejeita-se H0
# p-valor > 0,05 - Indica que a série é estacionária ###
ur.kpss(APlog.dif2)

# Teste para tendência
cox.stuart.test(APlog.dif2)
# H0: Não existe tendência
# H1: Existe tendência
# Se p-valor é menor que alfa, rejeita-se H0.
# A série não possui tendência. 

# Também pode ser usado o teste de Mann Kendall

# Para verificar a Sazonalidade
# Friedman
# Kruskall Wallis

#ggtsdisplay(APlog.dif2)


# AR(p) - função de autocorrelação parcial
# MA(q) - função de autocorrelação
# ARMA(p,q)
# ARIMA(p,d,q)
# SARIMA(1,1,1)(1,1,1)


x11()
par(mfrow=c(1,2))
acf(APlog.dif2) # Identifica a parte de MA

#m1 <- acf(APlog.dif2, plot = F)
#m1$lag <- m1$lag*12
#plot(m1, main = "ACF da série com diferença Simples e Sazonal")

pacf(APlog.dif2) # AR
# PACF ou FACP

#m2 <- pacf(APlog.dif2, plot = F)
#m2$lag <- m2$lag*12
#plot(m2, main = "FACP da série com diferença Simples e Sazonal")



#SARIMA(0,1,1)(0,1,1)

auto.arima(APlog)

# realiza a verificação dos possíveis modelos gerados a partir da série temporal
# em questão, visando ao ajuste ideal.


########################################
### Estimando o modelo
########################################

# SARIMA(1,1,1)(1,1,1)

#Arima(AirPassengers, order = c(1,1,1), seasonal = c(1,1,1), lambda = 0) 
#função 'Arima'(Arima com 'a' maiúsculo)do pacote forecast. O lambda = 0 permite que seja feita a transformação logarítmica
#não é preciso diferenciar a série pois a própria função faz isso
#ou

modelo1 <- arima(APlog, order = c(1,1,1), 
                 seasonal = list(order=c(1,1,1)))
x11()
acf(modelo1$residuals)
pacf(modelo1$residuals)
confint(modelo1)
modelo1$coef

# os paramêtros da parte AR não sazonal e sazonal são não significativos 
# (pois contém o zero no intervalo),
# logo, devem ser retirados e o modelo reestimado

# SARIMA(0,1,1)(0,1,1)

modelo2 <- arima(APlog, order = c(0,1,1),
                 seasonal = list(order=c(0,1,1)))
x11()
acf(modelo2$residuals)
pacf(modelo2$residuals)
confint(modelo2)
modelo2$coef

modelo3 <- arima(APlog, order = c(0,1,1), 
                 seasonal = list(order=c(0,1,1)))
x11()
acf(modelo3$residuals)
pacf(modelo3$residuals)
confint(modelo3)
modelo3$coef
# parâmetro significativo, pois não contém o zero no intervalo
# Os parâmetros dos modelos são significantes, o que implica na necessidade da 
# análise de seus resíduos para verificar se os modelos são adequados.


########################################
### Verificação do modelo
########################################

x11()
tsdiag(modelo3) 
# retorna o gráfico dos resíduos padronizados, 
# o correlograma e os
# p-valores do testes Ljung-Box, que devem estar acima de 0 para indicar
# que os resíduos são independentes.

# H0: Autocorrelações até lag k são iguais a 0 
#(não existe dependência linear entre os resíduos)

Box.test(modelo3$residuals) 
Box.test(modelo2$residuals)
Box.test(modelo1$residuals)

# P-valores superiores ao nível de significância (alpha = 0,05)
# indicam que os resíduos se comportam como um ruído branco. Portanto, 
# não rejeta H0
# Logo, ao nível de 5% de significância, 
# não rejeita-se a hipótese de que as autocorrelações não são significantes, 
# ou seja, os resíduos se comportam como ruído branco 
# e o modelo está ajustado adequadamente

Box.test(modelo3$residuals, type = c("Ljung-Box"))

#checkresiduals(modelo3)
x11()
hist(modelo3$residuals)
qqnorm(modelo3$residuals)
qqline(modelo3$residuals)
shapiro.test(modelo3$residuals)

#O teste Shapiro-Wilk tem como hipótese nula a normalidade. 
# Se p-valor < 0,05, rejeita-se a normalidade. 
#Como p-valor > 0,05 não podemos rejeitar que os resíduos são
#normalmente distribuídos.


# Critérios de comparação dos modelos 

AIC(modelo1)
AIC(modelo2)
AIC(modelo3)

BIC(modelo1)
BIC(modelo2)
BIC(modelo3)

# o melhor modelo será aquele que apresentar menor AIC e BIC

############################
##Previsão do modelo
############################

accuracy(modelo3)

x11()
prev <- forecast(modelo3, h=12)
plot(prev)

AirPassengers

# prev = Cálculo com o R das previsões pontuais 
#e intervalos de 80 e 95% de confiança 


# Previsões para a série transformada

p = as.data.frame(predict(modelo3, 12, interval="prediction")); p

### Predições para "12" períodos seguintes e os respectivos erros padrão ###


# Intervalo de confiança 95%
LI = exp(p$pred - 1.96*p$se)
LI
LS=exp(p$pred + 1.96*p$se)
LS

data.frame(p$pred,LI,LS)

# Previsões para a série original - segue o que diz Morettin e Toloi (2004, p.233)

previsoes = exp(p$pred + modelo3$sigma2/2)

df = data.frame(previsoes,LI,LS)
df

AP
#print(df,row.names=FALSE)

### Limite Inferior, Previsões, Limite Superior ###

############################
## Extraindo as previsões
############################
#Em formato .csv:

write.csv2(df,"C://Users//Lulu//Documents//UNIR_2021//Series Temporais//previsao.csv")

#Em formato .xlsx :
require(xlsx)
write.xlsx(prev,"C://Users//Lulu//Documents//UNIR_2021//Series Temporais//previsao.xlsx")



x = data.frame(AirPassengers)
linhas = c(133:144)
x.novo = x[linhas,]
data.frame(x.novo,previsoes)



#################
# Outras formas
# https://rpubs.com/Possato/ARIMA_ajuste_tutorial
# https://github.com/pedrocostaferreira/SeriesTemporais/blob/master/Aula7_ModelagemAirpassengers.R
x11()
d=seq(range(modelo3$residuals)[1]-3*sd(modelo3$residuals),range(modelo3$residuals)[2]+3*sd(modelo3$residuals),0.001)
lines(d,dnorm(d,0,sd(modelo3$residuals)))
#previsoes para 15 periodos seguintes e respectivos erros padroes
pmodelo3=predict(modelo3,n.ahead=12, se.fit=T)
pmodelo3
plot(ts(c(APlog,pmodelo3$pred)))
APlog
plot(ts(c(APlog,pmodelo3$pred),frequency=12,start=c(1949,1)))
abline(v=c(1961,1),lty=2)
lines(pmodelo3$pred+1.96*pmodelo3$se,col=2)
lines(pmodelo3$pred-1.96*pmodelo3$se,col=2)


